
#pragma kernel Init
#pragma kernel Advect
#pragma kernel UpdateH
#pragma kernel UpdateVels
#pragma kernel BlurH

SamplerState linear_clamp_sampler;

Texture2D<float> _H0;
RWTexture2D<float> _H1;
Texture2D<float> _Vx0;
RWTexture2D<float> _Vx1;
Texture2D<float> _Vy0;
RWTexture2D<float> _Vy1;

float _Time;
float _DomainWidth;
float _Res;
float _Drain;
float _Friction;
float _MaxVel;

#define DT 0.01

float2 IdToWorldXZ_H(uint2 id)
{
	// H grid is centered
	return ((id + 0.5) / _Res - 0.5) * _DomainWidth;
}
float2 IdToWorldXZ_Vx(uint2 id)
{
	// Vx grid is offset right half a texel
	return ((id + float2(1.0, 0.5)) / _Res - 0.5) * _DomainWidth;
}
float2 IdToWorldXZ_Vy(uint2 id)
{
	// Vy grid is offset forward half a texel
	return ((id + float2(0.5, 1.0)) / _Res - 0.5) * _DomainWidth;
}

float2 WorldXZToUv_H(float2 worldXZ)
{
	// H grid is centered
	return worldXZ / _DomainWidth + 0.5;
}
float2 WorldXZToUv_Vx(float2 worldXZ)
{
	// Vx grid is offset right half a texel
	return worldXZ / _DomainWidth + 0.5 - float2(0.5 / _Res, 0.0);
}
float2 WorldXZToUv_Vy(float2 worldXZ)
{
	// Vy grid is offset forward half a texel
	return worldXZ / _DomainWidth + 0.5 - float2(0.0, 0.5 / _Res);
}

float SampleH(float2 worldXZ)
{
	return _H0.SampleLevel(linear_clamp_sampler, WorldXZToUv_H(worldXZ), 0.0).x;
}
float SampleVx0(float2 worldXZ)
{
	return _Vx0.SampleLevel(linear_clamp_sampler, WorldXZToUv_Vx(worldXZ), 0.0).x;
}
float SampleVy0(float2 worldXZ)
{
	return _Vy0.SampleLevel(linear_clamp_sampler, WorldXZToUv_Vy(worldXZ), 0.0).x;
}

float g(float2 worldXZ)
{
	float g = 0.0;
	g += 1.5 * smoothstep(2.0, 0.0, length(worldXZ - 4.0));
	return g;
}

[numthreads(8, 8, 1)]
void Init(uint2 id : SV_DispatchThreadID)
{
	const float2 worldXZ_H = IdToWorldXZ_H(id);
	float h = 0.0; // .4 + .06 * dot(worldXZ_H, 1);
	//h = 4. * smoothstep(5.0, 0.0, length(worldXZ_H));

	h = max(0.0, h - g(worldXZ_H));

	_H1[id.xy] = h;
	_Vx1[id.xy] = 0.0;
	_Vy1[id.xy] = 0.0;
}

[numthreads(8, 8, 1)]
void Advect(uint2 id : SV_DispatchThreadID)
{
	// H
	{
		const float2 worldXZ_H = IdToWorldXZ_H(id);

		const float vx = SampleVx0(worldXZ_H);
		const float vy = SampleVy0(worldXZ_H);

		const float2 worldXZAdvected = worldXZ_H - DT * float2(vx, vy);

		_H1[id] = SampleH(worldXZAdvected);
	}

	// Vx
	{
		const float2 worldXZ_Vx = IdToWorldXZ_Vx(id);
		
		const float vx = SampleVx0(worldXZ_Vx); // Can be load
		const float vy = SampleVy0(worldXZ_Vx);

		const float2 worldXZAdvected = worldXZ_Vx - DT * float2(vx, vy);
		float vxAdvected = SampleVx0(worldXZAdvected);

		const float h_vx = SampleH(worldXZAdvected);
		const float friction = _Friction * DT / max(0.001f, pow(h_vx, 1.333333f));
		vxAdvected -= abs(vxAdvected) * vxAdvected * friction;

		vxAdvected = clamp(vxAdvected, -_MaxVel, _MaxVel);

		_Vx1[id] = vxAdvected;
	}

	// Vy
	{
		const float2 worldXZ_Vy = IdToWorldXZ_Vy(id);
		
		const float vx = SampleVx0(worldXZ_Vy);
		const float vy = SampleVy0(worldXZ_Vy); // Can be load
		
		const float2 worldXZAdvected = worldXZ_Vy - DT * float2(vx, vy);
		float vyAdvected = SampleVy0(worldXZAdvected);

		const float h_vy = SampleH(worldXZAdvected);
		const float friction = _Friction * DT / max(0.001f, pow(h_vy, 1.333333f));
		vyAdvected -= abs(vyAdvected) * vyAdvected * friction;

		vyAdvected = clamp(vyAdvected, -_MaxVel, _MaxVel);

		_Vy1[id] = vyAdvected;
	}
}

[numthreads(8,8,1)]
void UpdateH(uint2 id : SV_DispatchThreadID)
{
	float h = _H1[id];

	const uint x = id.x;
	const uint y = id.y;
	const uint xm = max(x - 1, 0);
	const uint ym = max(y - 1, 0);

	const float grid = _DomainWidth / _Res;

	float pump = _Drain;
	if (length(IdToWorldXZ_H(id) - float2(-14.0, 14.0)) < 1.0)
	{
		float targetHeight = 4.0;
		float pumpIn = 0.01 * (targetHeight - h);
		float maxPump = 0.04;
		if (abs(pumpIn) > maxPump) pumpIn *= maxPump / abs(pumpIn);
		pump += pumpIn;
	}

	const float dx = (_Vx1[id] - _Vx1[uint2(xm, y)]) / grid;
	const float dy = (_Vy1[id] - _Vy1[uint2(x, ym)]) / grid;
	const float divergence = dx + dy;

	// Update height based on total flow in minus total flow out
	const float hvel = -h * divergence;
	//hvel = clamp(hvel, -32.0f, 32.0f);

	h += DT * hvel + pump;

	// Dry - force to 0
	if (h < 0.001) h = 0.0;

	// Pull down height at boundaries
	//if (id.x == 0 || id.y == 0 || id.x == _Res - 1 || id.y == _Res - 1) h = lerp(h, 120.5, 0.01);

	//if(length(IdToWorldXZ_H(id)) < 4.0) h = 0;

	_H1[id] = h;
}

[numthreads(8, 8, 1)]
void UpdateVels(uint2 id : SV_DispatchThreadID)
{
	// Height before vel
	const float2 worldXZ_H0 = IdToWorldXZ_H(id);
	const float g0 = g(worldXZ_H0);
	const float h0 = _H1[id];

	const uint x = id.x;
	const uint y = id.y;
	const uint xp = min(x + 1, _Res - 1);
	const uint yp = min(y + 1, _Res - 1);

	const float grid = _DomainWidth / _Res;
	const float gravity = 9.81f;

	// Vx
	{
		float vx = _Vx1[id];

		const float2 worldXZ_H1 = IdToWorldXZ_H(uint2(xp, y));
		const float g1 = g(worldXZ_H1);
		const float h1 = _H1[uint2(xp, y)];

		const float hdiff = (h1 + g1) - (h0 + g0);
		//if (fabs(hdiff) > maxDiff) hdiff = sign(hdiff) * maxDiff;

		float accel = -gravity * hdiff / grid;

		vx += DT * accel;

		if (accel < 0 && h1 < 0.001)
		{
			vx = 0.0;
		}
		else if (accel > 0 && h0 < 0.001)
		{
			vx = 0.0;
		}

		/*if (abs(vx) > maxVel)
		{
			vx = sign(vx) * maxVel;
		}*/

		_Vx1[id] = vx;
	}

	// Vy
	{
		float vy = _Vy1[id];

		const float2 worldXZ_H1 = IdToWorldXZ_H(uint2(x, yp));
		const float g1 = g(worldXZ_H1);
		const float h1 = _H1[uint2(x, yp)];

		const float hdiff = (h1 + g1) - (h0 + g0);
		//if (fabs(hdiff) > maxDiff) hdiff = sign(hdiff) * maxDiff;

		float accel = -gravity * hdiff / grid;

		vy += DT * accel;

		if (accel < 0 && h1 < 0.001)
		{
			vy = 0.0;
		}
		else if (accel > 0 && h0 < 0.001)
		{
			vy = 0.0;
		}

		/*if (abs(vx) > maxVel)
		{
			vx = sign(vx) * maxVel;
		}*/

		_Vy1[id] = vy;
	}
}

[numthreads(8, 8, 1)]
void BlurH(int2 id : SV_DispatchThreadID)
{
	float result = 0.0;
	float twt = 0.0;
	const int rad = 2;

	float hcenter = _H0[id];
	if (hcenter < 0.001)
	{
		_H1[id] = 0.0;
		return;
	}

	for (int y = -rad; y <= rad; y++)
	{
		for (int x = -rad; x <= rad; x++)
		{
			int2 idx;
			idx.x = clamp(id.x + x, 0, _Res - 1);
			idx.y = clamp(id.y + y, 0, _Res - 1);

			float h = _H0[idx];
			float wt = h >= 0.001 ? 1.0 : 0.0;
			result += wt * h;
			twt += wt;
		}
	}


	_H1[id] = twt > 0.0 ? result / twt : hcenter;
}
